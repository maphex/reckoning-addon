name: Monitor CurseForge Releases

on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch: # Allow manual triggering for testing

jobs:
  check-version:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          ref: curseforge-state
          path: state-repo
        continue-on-error: true

      - name: Load previous version
        run: |
          if [ -f state-repo/last-version.txt ]; then
            cp state-repo/last-version.txt .
          fi

      - name: Check CurseForge for new version
        id: check
        env:
          CF_API_KEY: ${{ secrets.CF_REST_API_KEY }}
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          # Read last seen version if exists
          LAST_VERSION=""
          if [ -f last-version.txt ]; then
            LAST_VERSION=$(cat last-version.txt)
            echo "Last seen version: $LAST_VERSION"
          else
            echo "No previous version found, this is first run"
          fi

          # Query CurseForge API for latest files (fetch 10 to ensure we get the latest)
          echo "Querying CurseForge API for project 1453511..."
          RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
            -H "Accept: application/json" \
            -H "x-api-key: $CF_API_KEY" \
            "https://api.curseforge.com/v1/mods/1453511/files?index=0&pageSize=10")

          # Extract HTTP code
          HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
          RESPONSE=$(echo "$RESPONSE" | sed '/HTTP_CODE:/d')

          echo "HTTP Status: $HTTP_CODE"

          # Check if response is valid
          if [ -z "$RESPONSE" ] || ! echo "$RESPONSE" | jq -e '.data' > /dev/null 2>&1; then
            echo "âŒ Error: Failed to get valid response from CurseForge API"
            echo "API Response:"
            echo "$RESPONSE" | jq '.' || echo "$RESPONSE"
            exit 1
          fi

          echo "âœ“ Successfully fetched files from API"
          FILE_COUNT=$(echo "$RESPONSE" | jq '.data | length')
          echo "Found $FILE_COUNT files"

          # Sort by fileDate and get the most recent file
          LATEST_FILE=$(echo "$RESPONSE" | jq -r '.data | sort_by(.fileDate) | reverse | .[0]')

          # Extract latest version info
          LATEST_VERSION=$(echo "$LATEST_FILE" | jq -r '.displayName')
          FILE_ID=$(echo "$LATEST_FILE" | jq -r '.id')
          DOWNLOAD_URL=$(echo "$LATEST_FILE" | jq -r '.downloadUrl')
          UPLOAD_TIME=$(echo "$LATEST_FILE" | jq -r '.fileDate')

          echo "Latest version: $LATEST_VERSION"
          echo "File ID: $FILE_ID"

          # Check if version is new
          if [ "$LATEST_VERSION" != "$LAST_VERSION" ] && [ -n "$LATEST_VERSION" ] && [ "$LATEST_VERSION" != "null" ]; then
            echo "New version detected: $LATEST_VERSION"
            echo "new_version=true" >> $GITHUB_OUTPUT

            # Send Discord webhook notification
            if [ -n "$DISCORD_WEBHOOK" ]; then
              echo "Sending Discord notification..."

              WEBHOOK_DATA=$(cat <<EOF
          {
            "embeds": [{
              "title": "ðŸŽ® New Reckoning Version Released!",
              "description": "A new version of Reckoning has been published on CurseForge",
              "color": 5814783,
              "fields": [
                {
                  "name": "Version",
                  "value": "$LATEST_VERSION",
                  "inline": true
                },
                {
                  "name": "File ID",
                  "value": "$FILE_ID",
                  "inline": true
                },
                {
                  "name": "Released",
                  "value": "$UPLOAD_TIME",
                  "inline": false
                }
              ],
              "url": "https://www.curseforge.com/wow/addons/reckoning/files/$FILE_ID",
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)"
            }]
          }
          EOF
              )

              curl -H "Content-Type: application/json" \
                -d "$WEBHOOK_DATA" \
                "$DISCORD_WEBHOOK"

              echo "Discord notification sent successfully!"

              # Only save new version after successful webhook delivery
              echo "$LATEST_VERSION" > last-version.txt
            else
              echo "âš ï¸  WARNING: New version detected but DISCORD_WEBHOOK secret not configured!"
              echo "âš ï¸  Not updating last-version.txt so notification will retry when webhook is configured"
              echo "âš ï¸  New version: $LATEST_VERSION"

              # Keep the old version so we retry notification when webhook is configured
              if [ -n "$LAST_VERSION" ]; then
                echo "$LAST_VERSION" > last-version.txt
              fi
            fi
          else
            echo "No new version detected"
            # Keep the last version file as-is
            if [ -n "$LAST_VERSION" ]; then
              echo "$LAST_VERSION" > last-version.txt
            else
              # First run with no new version - save current version
              echo "$LATEST_VERSION" > last-version.txt
            fi
          fi

      - name: Save version to state branch
        if: always() && hashFiles('last-version.txt') != ''
        run: |
          # If state-repo doesn't exist, create and initialize it
          if [ ! -d state-repo/.git ]; then
            echo "Initializing state repository..."
            mkdir -p state-repo
            cd state-repo
            git init
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git checkout -b curseforge-state
            git remote add origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
            cd ..
          fi

          # Copy the version file
          cp last-version.txt state-repo/

          # Commit and push if there are changes
          cd state-repo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add last-version.txt

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update last CurseForge version to $(cat last-version.txt)"
            git push -f origin curseforge-state
            echo "âœ“ State saved to curseforge-state branch"
          fi
