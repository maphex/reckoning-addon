name: Monitor CurseForge Releases

on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch: # Allow manual triggering for testing

permissions:
  contents: write # Required to push to branches

jobs:
  check-version:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4

      - name: Load previous version from state branch
        continue-on-error: true
        run: |
          # Try to fetch the state branch and read the version file
          if git ls-remote --heads origin curseforge-state | grep -q curseforge-state; then
            echo "State branch exists, fetching..."
            git fetch origin curseforge-state
            # Read file directly from remote branch without checking it out
            SAVED_VERSION=$(git show origin/curseforge-state:last-version.txt 2>/dev/null || echo "")
            if [ -n "$SAVED_VERSION" ]; then
              echo "$SAVED_VERSION" > last-version.txt
              echo "Loaded previous version: $SAVED_VERSION"
            fi
          else
            echo "State branch doesn't exist yet (first run)"
          fi

      - name: Check CurseForge for new version
        id: check
        env:
          CF_API_KEY: ${{ secrets.CF_REST_API_KEY }}
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          # Read last seen version if exists
          LAST_VERSION=""
          if [ -f last-version.txt ]; then
            LAST_VERSION=$(cat last-version.txt)
            echo "Last seen version: $LAST_VERSION"
          else
            echo "No previous version found, this is first run"
          fi

          # Query CurseForge API for latest files (fetch 10 to ensure we get the latest)
          echo "Querying CurseForge API for project 1453511..."
          RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
            -H "Accept: application/json" \
            -H "x-api-key: $CF_API_KEY" \
            "https://api.curseforge.com/v1/mods/1453511/files?index=0&pageSize=10")

          # Extract HTTP code
          HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
          RESPONSE=$(echo "$RESPONSE" | sed '/HTTP_CODE:/d')

          echo "HTTP Status: $HTTP_CODE"

          # Check if response is valid
          if [ -z "$RESPONSE" ] || ! echo "$RESPONSE" | jq -e '.data' > /dev/null 2>&1; then
            echo "âŒ Error: Failed to get valid response from CurseForge API"
            echo "API Response:"
            echo "$RESPONSE" | jq '.' || echo "$RESPONSE"
            exit 1
          fi

          echo "âœ“ Successfully fetched files from API"
          FILE_COUNT=$(echo "$RESPONSE" | jq '.data | length')
          echo "Found $FILE_COUNT files"

          # Sort by fileDate and get the most recent file
          LATEST_FILE=$(echo "$RESPONSE" | jq -r '.data | sort_by(.fileDate) | reverse | .[0]')

          # Extract latest version info
          LATEST_VERSION=$(echo "$LATEST_FILE" | jq -r '.displayName')
          FILE_ID=$(echo "$LATEST_FILE" | jq -r '.id')
          DOWNLOAD_URL=$(echo "$LATEST_FILE" | jq -r '.downloadUrl')
          UPLOAD_TIME=$(echo "$LATEST_FILE" | jq -r '.fileDate')

          echo "Latest version: $LATEST_VERSION"
          echo "File ID: $FILE_ID"

          # Check if version is new
          if [ "$LATEST_VERSION" != "$LAST_VERSION" ] && [ -n "$LATEST_VERSION" ] && [ "$LATEST_VERSION" != "null" ]; then
            echo "New version detected: $LATEST_VERSION"
            echo "new_version=true" >> $GITHUB_OUTPUT

            # Send Discord webhook notification
            if [ -n "$DISCORD_WEBHOOK" ]; then
              echo "Sending Discord notification..."

              WEBHOOK_DATA=$(cat <<EOF
          {
            "embeds": [{
              "title": "ðŸŽ® New Reckoning Version Released!",
              "description": "**$LATEST_VERSION** is now available on CurseForge",
              "color": 5814783,
              "fields": [
                {
                  "name": "ðŸ“… Released",
                  "value": "<t:$(date -d "$UPLOAD_TIME" +%s):R>",
                  "inline": true
                },
                {
                  "name": "ðŸ”— Download",
                  "value": "[CurseForge](https://www.curseforge.com/wow/addons/reckoning/files/$FILE_ID)",
                  "inline": true
                }
              ],
              "url": "https://www.curseforge.com/wow/addons/reckoning/files/$FILE_ID",
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)"
            }]
          }
          EOF
              )

              curl -H "Content-Type: application/json" \
                -d "$WEBHOOK_DATA" \
                "$DISCORD_WEBHOOK"

              echo "Discord notification sent successfully!"

              # Only save new version after successful webhook delivery
              echo "$LATEST_VERSION" > last-version.txt
            else
              echo "âš ï¸  WARNING: New version detected but DISCORD_WEBHOOK secret not configured!"
              echo "âš ï¸  Not updating last-version.txt so notification will retry when webhook is configured"
              echo "âš ï¸  New version: $LATEST_VERSION"

              # Keep the old version so we retry notification when webhook is configured
              if [ -n "$LAST_VERSION" ]; then
                echo "$LAST_VERSION" > last-version.txt
              fi
            fi
          else
            echo "No new version detected"
            # Keep the last version file as-is
            if [ -n "$LAST_VERSION" ]; then
              echo "$LAST_VERSION" > last-version.txt
            else
              # First run with no new version - save current version
              echo "$LATEST_VERSION" > last-version.txt
            fi
          fi

      - name: Save version to state branch
        if: always() && hashFiles('last-version.txt') != ''
        run: |
          # Save the version content before switching branches
          SAVED_VERSION=$(cat last-version.txt)

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if state branch exists on remote
          if git ls-remote --heads origin curseforge-state | grep -q curseforge-state; then
            echo "State branch exists, checking it out..."
            git fetch origin curseforge-state
            git checkout curseforge-state
          else
            echo "Creating new orphan state branch..."
            git checkout --orphan curseforge-state
            git rm -rf . 2>/dev/null || true
          fi

          # Write the saved version
          echo "$SAVED_VERSION" > last-version.txt

          # Add and commit if there are changes
          git add last-version.txt

          if git diff --staged --quiet 2>/dev/null; then
            echo "No changes to commit"
          else
            git commit -m "Update last CurseForge version to $SAVED_VERSION"
            git push origin curseforge-state
            echo "âœ“ State saved to curseforge-state branch"
          fi
